# 简介 #
**中心目标**  
1. 展示web基础技术--http应用协议、url命名标准、xml标记语言、使用场合及局限性。  
2. web的一套设计原则。Representational State Transfer，表示性状态转移，简称rest。  
3. 面向资源架构 Resource-Oriented Architecture，简称ROA    

**简单的web**  
1. 原来http 0.9协议，如此单调。。。  
http特别适合分布式internet应用，因为它没有值的一提的特性。你要什么，我便给你什么。缺点转化为优势，简单性便是他最大的能力。  
2. http 0.9看到：可寻址性，无状态性  
3. web依赖的两项技术：url，html和xml  

**大web服务**  
1. wsdl，soap  
2. 大web服务效果：http成为传输庞大xml负载的协议，真正的描述信息在xml中，比如soap。  
3. 适应性，可扩展性，可维护性意味着出错点越多，以此忽略了http 0.9，的简单性。辩证法啊！！！  
4. ROA定义为一种替代RPC式（soap+wsdl）的简单方案。  
5. rpc暴露的是算法，这种服务，每个接口都不同；roa暴露的是内部数据，接口是统一的**？？？**  

# 第一章 可编程的web #

**分类**  
1. 不采用http，就不是基于web的。绝对正确！！

**方法信息**  
1.对数据采取什么样的操作，成为方法信息。其实就是put，get，post，delete，head等http请求的几种方法  
2. soap服务的方法信息是放在http消息体中的，这个很直观；  
3. 观察google的搜索，发出的是get请求，这个方法信息是放在请求行中的，不在请求头和消息体中！  

**作用域信息**  
这段比较有意思：  
采用什么样的服务设计，决定了哪些信息属于方法信息，哪些信息属于作用域信息。  
两个uri：  
`http://flickr.com/photos/tags/penguin`  
`http://api.flickr.com/services/rest/?method=flickr.photo.serarch&tag=pengunin`  

第一个uri：方法信息是获取（get），作用域信息是具有penguin的标签的照片  
第二个uri：方法信息是搜索照片，作用域信息是具有penguin的标签  
技术上看，两者没有区别，他们的http请求都是get请求。  
仔细揣摩`method=flickr.photo.serarch`这个方法使得http本身的GET方法失去了本意！！！  
这两者架构上是有区别的！！！  
感觉好像是有那么点不同，但是说不上来！！！  

**rest式，面向资源的的架构**  
1. rest式架构意味着：方法信息都在HTTP方法中；roa架构意味着，作用域信息都在uri中。一个面向资源的rest式web服务，通过http请求行就可以了解用户要做什么了。  
`GET /reports/open-bugs HTTP/1.1`  
简单命令，我就是要获取这个uri中表示的资源！！  
如果作用域信息不放在uri中，那么服务就不是面向资源的！  
2. 一些知名的rest式面向资源的web服务：  
--雅虎的web服务  
--web应用，尤其是搜索引擎这种只读的服务  

**Rpc式架构**  
1. rpc式架构意味着：方法信息和作用域信息都在信封或报头，即消息体和消息头中；soap是典型的rpc式架构。    
2. 各个rpc服务采用自己的词汇，各个方法都不一样；而rest式web服务都一样，采用HTTP公用的方法；  
3. rpc式服务只暴露一个uri，具体的方法信息和作用域放在了消息体中传送，并且只支持一种HTTP方法-POST；但是，rest式服务就不一样了，它为不同的的作用域暴露不一样的uri，它发出的HTTP请求中不包含消息体，消息体是空的！！    
4. 只采用post方法的服务，多半是rpc服务。不绝对！

**混合架构**  
`http://api.flickr.com/services/rest/?method=flickr.photo.serarch&tag=pengunin`  
这个请求，方法信息是search操作，作用域是带penguin；  
方法信息搜索照片放在uri中，对于rest服务，方法信息应该放在http方法里，其余部分全部作为作用域信息。    
作用域信息在uri中，比较像面向资源的服务。  
所以，这是个rpc式的服务，鉴定完毕！！  
```    
GET services/rest?api_key=xxx&method=flickr.photo.serarch&tag=pengunin HTTP/1.1
```  
且看这个请求，大眼看上去，采用了get请求，作用域也在uri中，但这只是一个错觉。  
这个是rest-rpc混合服务。  


**http**  
1. 所有的web都采用http，不过使用方式不一样。  
2. rest式web，它的方法信息就是http方法中的某一个，作用域信息在uri中。  
3. rpc式web，方法信息和作用域信息在消息头和消息体中；它常把http作为容纳文档的信封，甚至是容纳另一种信封的信封（soap）    


**uri**  
1. 所有的web服务都用uri，不过有差异。  
2. rest式面向资源的服务会为客户端可能操作的每一则数据暴露一个uri。  
3. rest-rpc混合式，为客户端进行的每一个操作，暴露一个uri（如删除数据用一个uri，获取数据用一个uri）。  
4. rpc式，为每一个远程调用的进程暴露一个uri，一般来说这样的uri只有一个，即endpoint。其中，调用的方法和参数等信息，放入信封中信封中，即放入http消息体中。  

**soap**  
1. 基本上每个采用soap的web服务都属于rpc式架构。  
2. 真正的问题是：放在http信封的实体可以包含任何数据，soap信封中含有的xml数据是对一个rpc调用的描述。  

**wsdl**  
wsdl-web服务描述语言，其实是描述soap web服务的xml语法规则。通过wsdl文档，可以了解有哪些rpc方法，参数，返回值。   

**wadl**
wasl：web应用服务描述语言，描述rest式web服务的xml词汇。 


# 第二章 编写web服务客户端 #

**网站和web服务细微的差异**  
在网站上看的东西，请求发出去，返回的是html文档；  
web服务的话，返回的是xml文档，然后把xml文档解析，获取数据，重新组装。  

**XPath讲解**  
以从右往左的顺序读取`/posts/post`这个XPath表达式：  
寻找所有post标签：`post`  
哪里的post标签？直接在posts标签下的 `posts/`  
哪里的posts标签？文档根部的`/`  


**可选特性**  
1.请求压缩格式，收到数据自动解压。  
请求头是`Accept-Edcoding`  
响应头是`Encoding`    
*encoding:编码，将文字信息译成密码，即压缩。*  

2.缓存。  
请求头是`Etag ，If-Modified-Since`  
响应头是`Etay , Last-modified`


**xml文档解析器**  
1. 基于文档的。  
DOM树式解析器；基于文档的解析器把xml文档建模为一种嵌套的数据结构。这种数据结构，可以用XPath查询，css选择器查询和处理。    
`最大的缺点`：必须把整个xml文档作为整体处理，需要载入整个内存，如果需要打文档，比较低效。  
`最大的优点`： 随机访问文档中的内容。而对于事件式的，事件触发之后，就没有再次处理了。如果想触发它，就得重新解析该文档。    
2. 基于事件的。      
SAX式或拖式（pull）是把xml文档转换成一个事件流，而不是数据结构。   
注：java中有dom解析和sax解析。  
dom解析在`org.xml.dom.*`中  
sx接口在`org.xml.sax.*`中


**wadl简化客户端的编写**
三部走策略：  
1. 准备好要放入http请求的数据（http方法，uri，报头，实体）  
2. 调用http库，把数据变为真正的http请求，发送服务  
3. 用xml解析器把http响应解析为一个数据结构或一系列事件  


# 第三章 rest服务有什么特别的不同 #
**S3的面向对象设计**  
s3的两个概念：桶，对象  
对象：元数据  
桶：容纳对象的容器  

**put和post请求的区别**  
```
put在http的语义是idempotence。
在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同；是指可以使用相同参数重复执行，并能获得相同结果的函数。而post并不具备这样的语义。  
```    


**面向资源的架构**  
ROA的四个特性：  
1. 可寻址性。作用域信息，放在uri中。  
2. 统一接口原则。方法信息，放在http的方法中。  
3. 无状态性。各个请求之间是独立的。每次交互都只包括单个请求。    
4. 连通性。  

**面向资源的架构？**  
rest不是一种架构，而是一种设计原则。  
这句话解释的比较好：在遵守这些原则方面，一个架构做的比另一个架构好。但是不能说rest架构，因为不存在一个叫rest架构的东西。  

**什么是资源**  
一个资源就是某个可以存放在计算机上并体现为比特流的事务。  
比如：一个文档，数据库的一条记录，运行某个算法的结果等等；或者也可以是一个抽象的概念（比如勇气）  

**uris**  
uri是资源的名称，也是资源的地址。对于web服务而言，通过uri，就可以定位到这个资源。  

**无状态性**  
改变无状态性，最常用的方法是利用http会话（session）。  
用户首次登陆的时候，获取一个唯一的字符串，用以标识他在该网站的会话。这个字符串可以保存在cookie里，也可以放在该用户的uri中。  
需要注意的是：这些字符串不是状态。状态保存在服务器端的某个数据结构中。  

**应用状态VS资源状态**  
无状态意味着：有一种状态，是服务器不应保存的。  
状态分两种：应用状态，资源状态。  
前者保存在客户端，后者保存在服务端。  

**应用状态**：比如使用搜索引擎时，我看的页面是水母所搜的第三页，你看到的是老鼠搜索结果的第一页；这是两个针对客户端的应用状态；一个web服务，只有收到你的请求时，才关心你的应用状态，其它时刻，你的存在对它没有任何意义。也就是说客户端在向服务器发送请求的时候，必须携带服务器处理这个请求所需要的所有应用状态。服务端返回结果给客户端，然后这次交互就结束了。 下个请求就是一个新的交互，这是web服务的所说的无状态。  

**资源状态**：对于客户端而言是相同的，它保存在服务器中。百度上的一张图片，他有一个独立的uri，每个人都可以访问。这是一个资源状态。  

**表示**  
表示是资源当前状态的一些数据。  
说白了，表示就是你想获取的是什么资源，资源的一种状态。  
新闻稿（一个资源，只有一个uri），有英语和中文，这是两种表示状态。

  
**连通性**  


**head和options**
head请求，获取数据的原信息，而不是获取数据的整个表示。  

**统一接口**


# 第五章 设计之都的面向资源的服务 #  
