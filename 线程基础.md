线程安全的概念：  
当多个线程访问某一个类的时候，这个类始终都能表现出正确的行为，那么这么个类（对象或方法）就是线程安全。

synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为互斥区。   
总结：  
一个线程想要执行synchronized修饰的方法时候：  
1. 首先尝试获得锁  
2. 如果拿到锁，执行synchronized代码内容；若拿不到，这个线程就不断的尝试获取这把锁，直到拿到为止；而且是多个线程同时去争夺这把锁。产生所竞争问题。后果应用程序cpu使用率会很高；  


多个线程，多个锁：  
关键字syncronized取得的锁是对象锁，而不是把一段代码（方法）当做锁。  
多个线程，同时访问一个类的多个实例对象的情况下：获取的是不同对象的锁，即不是同一把锁。即不是一个对象的同一把锁。
注：
如果在静态方法上加synchronized，那么一个线程获取的是这个类的锁，而不是一实例对象的锁；即这个是类级别的锁。  


##对象锁的同步和异步##

同步：synchronized  
同步的概念就是共享，如果资源不是共享的，那就没有必要进行同步。  

异步：asynchronized  
异步的概念是独立，互相之间没有影响；  

列子：  
1. a线程先持有object对象的lock锁，b线程如果这个时候调用对象中的同步方法则需等待，也就是同步；  
2. a线程先持有object对象的lock锁，b线程可以异步的调用对象中的非synchronized方法

<原来，以前的认知是错的。如果是一个对象，多个方法，都用syncrioized修饰，其中一个线程进入其中高一个方法后，别的线程是进入不了其他的方法的，因为synchrioized取得的是对象锁！！！而不是一段代码的锁！！！！只有等获取对象锁的线程释放锁后，别的线程才可以访问其他的synchrinozid方法>  


##脏读##
java多线程中的脏读：读取到了别人修改的值，并且是不希望读取到的值。
一般出现在业务本身具有原子性，但是没有进行同步操作，导致一部分数据修改了，一部分数据没有修改，
读出来的数据是错的。

oracle：undo概念，a客户端执行select操作，b客户端执行dml操作（insert，update等）；  
针对a客户端查询的那条数据，b进行了更新，因为b可能会更新失败，所以更新前这条数据数据会放在undo空间，假如更新失败，  
会把这条数据从undo空间取出，进行rollback回滚。  

而对于没有失败的情况，a先查询，b修改，a只会看到旧值，而不会看到b更改的值。    
snapshot too old:快照太老的异常    

##synchronized其他概念##  
1. 重入锁：这个对象的锁可以获取的。
2. sync修饰的方法出现了异常，会立即释放锁。  
意思是：一个业务整体，在执行过程中出现异常了，该如何做？  
 - 抛出一个RuntimeExcepption,这样即使在死循环中，也会中断；
 - continue，继续处理后续的（没有影响的）  
适用于多任务中，需要多任务必须同时成功或者失败，失败要回滚；  
或者失败记录日志

列子：存储过程书写中，10条记录遍历，其中第7条失败，不影响后续的，那就先写日志，继续；
对后续都有意影响，那就撤销之前的6条操作，全部回滚。记日志。  


----该看05