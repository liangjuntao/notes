线程安全的概念：  
当多个线程访问某一个类的时候，这个类始终都能表现出正确的行为，那么这么个类（对象或方法）就是线程安全。

synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为互斥区。   
总结：  
一个线程想要执行synchronized修饰的方法时候：  
1. 首先尝试获得锁  
2. 如果拿到锁，执行synchronized代码内容；若拿不到，这个线程就不断的尝试获取这把锁，直到拿到为止；而且是多个线程同时去争夺这把锁。产生所竞争问题。后果应用程序cpu使用率会很高；  


多个线程，多个锁：  
关键字syncronized取得的锁是对象锁，而不是把一段代码（方法）当做锁。  
多个线程，同时访问一个类的多个实例对象的情况下：获取的是不同对象的锁，即不是同一把锁。即不是一个对象的同一把锁。
注：
如果在静态方法上加synchronized，那么一个线程获取的是这个类的锁，而不是一实例对象的锁；即这个是类级别的锁。  


##对象锁的同步和异步##

同步：synchronized  
同步的概念就是共享，如果资源不是共享的，那就没有必要进行同步。  

异步：asynchronized  
异步的概念是独立，互相之间没有影响；  

列子：  
1. a线程先持有object对象的lock锁，b线程如果这个时候调用对象中的同步方法则需等待，也就是同步；  
2. a线程先持有object对象的lock锁，b线程可以异步的调用对象中的非synchronized方法

<原来，以前的认知是错的。如果是一个对象，多个方法，都用syncrioized修饰，其中一个线程进入其中高一个方法后，别的线程是进入不了其他的方法的，因为synchrioized取得的是对象锁！！！而不是一段代码的锁！！！！只有等获取对象锁的线程释放锁后，别的线程才可以访问其他的synchrinozid方法>  


##脏读##
java多线程中的脏读：读取到了别人修改的值，并且是不希望读取到的值。
一般出现在业务本身具有原子性，但是没有进行同步操作，导致一部分数据修改了，一部分数据没有修改，
读出来的数据是错的。

oracle：undo概念，a客户端执行select操作，b客户端执行dml操作（insert，update等）；  
针对a客户端查询的那条数据，b进行了更新，因为b可能会更新失败，所以更新前这条数据数据会放在undo空间，假如更新失败，  
会把这条数据从undo空间取出，进行rollback回滚。  

而对于没有失败的情况，a先查询，b修改，a只会看到旧值，而不会看到b更改的值。    
snapshot too old:快照太老的异常    

##synchronized其他概念##  
1. 重入锁：这个对象的锁可以获取的。
2. sync修饰的方法出现了异常，会立即释放锁。  
意思是：一个业务整体，在执行过程中出现异常了，该如何做？  
 - 抛出一个RuntimeExcepption,这样即使在死循环中，也会中断；
 - continue，继续处理后续的（没有影响的）  
适用于多任务中，需要多任务必须同时成功或者失败，失败要回滚；  
或者失败记录日志

列子：存储过程书写中，10条记录遍历，其中第7条失败，不影响后续的，那就先写日志，继续；
对后续都有意影响，那就撤销之前的6条操作，全部回滚。记日志。  


##synchronized代码块##  
弊端：a线程的同步方法执行较长时间，那么b线程就必须等待较长时间才能执行。
这种情况下可以采用sync代码块去优化执行时间，减小锁的粒度。  

注意：不要使用string的常量加锁，容易出现死循环。
sync修饰类实例对象的锁  
类锁A.class  
声明一个对象，对象锁  


sync修饰的非静态方法，获取的是实列对象的锁；  
sync修饰静态方法，获取的是类锁；  
对象锁和类锁不是同一把锁，锁的范围也不一样；两把锁，一个线程可以同时获取。  


java的内置锁：每个java对象都可以用作一个实现同步的锁，这些锁成为内置锁。  
线程进入同步方法，同步代码块，会自动获取。在退出方法，释放锁。  
获得内置锁的唯一方法就是进入这个锁保护的 同步代码块，或者同步锁。  

对象锁：用于对象实例方法，或者一个对象实列上。  
类锁：类的静态方法，一个类的class对象。  

例子：  
两个线程，一个对象。  
类中两个方法，一个修饰代码块，一个修饰方法。  
执行的效果是：t1线程执行完了之后，t2线程才能进来。  
因为修饰代码块，修饰方法竞争的是同一把锁，即对象的内置锁。  

例子：  
两个线程，一个对象。  
类中两个方法，一个修饰static静态方法，一个修饰类对象。  
效果：t1执行完，t2才能进来。  
因为修饰静态方法，修饰类对象，竞争的是同一把锁。即类锁。  

例子：  
两个线程，一个对象。  
类中两个方法，一个修饰静态方法，一个修饰非静态方法。  
效果：交叉执行。  
因为修饰静态方法获取的是类锁，修饰非静态方法获取的是对象的内置锁，这两把锁不是同一把锁。
固可以同时执行。  

采用同步代码块或者同步方法，都会造成阻塞。  
但是有另外一种方法，采用同步代码块，声明一个锁。Object lock = new Oject();
在同步代码块中，对这个sync(lock)加锁，就可以保证不会阻塞其他线程，获取类的实列对象的锁。  
因为lock的内置锁和实列对象的锁，不是同一锁。  
同时也避免了同步代码块中的方法实现原子性。  


例子：  
两个线程，一个对象。
类中一个非静态方法，采用同步代码块，sync修饰（字符串常量）  
效果：t1执行完毕后，t2才能执行。  
因为两个线程获取的是同一把锁。  


例子：  
两个线程，一个对象。  
类中一个非静态方法，采用同步代码块，sync（new String（""））  
效果：交替执行。  
因为new出来的是不是同一个对象，获取不同的锁。


例子：  
两个线程，一个对象。  
类中一个非静态方法，采用同步代码块。  
sync(lock)，lock是在类的成员变量，且为string类型。 
并且在同步代码快中，对这个lock进行了修改值。  
效果：交替执行。  
因为string对象发生变化了，不再是同一把锁。所以这个时候sync就没作用了。



死锁   
两个线程互相持有对象想获取的锁，线程t1想获取锁a，但是它持有锁b；
线程t2想获取锁b，但是它持有锁a；  
这种情况就会造成死锁。  


##volatile关键字##  
概念：使变量在多个线程间可见。 
作用：线程到主存（共享内存）中去读取变量，而不是在自己的工作内存。  


早期做法：  
变量加锁，t1修改后放回主存，t2获取锁，去主存拿值。保证数据一致性。  
效率低，只有等t1释放锁之后，t2才可以获取锁，去修改变量的值。  

疑问：  
main中创建一个线程，调用Thread.sleep()，这个是主线程休眠，还是创建的线程休眠；  

volitale只是具备了可见性，并不是说具备了原子性。  
对数值计算，采用原子类，实现原子性。  
volatile：多个线程的可见，不能代替sync的同步功能。  

疑问：sync效率低是因为需要获取锁，获取不到就等待；
那volatile修饰的变量，如果一个线程对这个值修改，死循环了。那别的变量获取到的不就不是最新的了么？  

原子类：
只保证本身方法的原子性，不保证多次操作的原子性。  

该看07