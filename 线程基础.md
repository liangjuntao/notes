##线程安全的概念：  
当多个线程访问某一个类的时候，这个类始终都能表现出正确的行为，那么这么个类（对象或方法）就是线程安全。

synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为互斥区。   
总结：  
一个线程想要执行synchronized修饰的方法时候：  
1. 首先尝试获得锁  
2. 如果拿到锁，执行synchronized代码内容；若拿不到，这个线程就不断的尝试获取这把锁，直到拿到为止；而且是多个线程同时去争夺这把锁。产生所竞争问题。后果应用程序cpu使用率会很高；  


多个线程，多个锁：  
关键字syncronized取得的锁是对象锁，而不是把一段代码（方法）当做锁。  
多个线程，同时访问一个类的多个实例对象的情况下：获取的是不同对象的锁，即不是同一把锁。即不是一个对象的同一把锁。
注：
如果在静态方法上加synchronized，那么一个线程获取的是这个类的锁，而不是一实例对象的锁；即这个是类级别的锁。  


##对象锁的同步和异步##

同步：synchronized  
同步的概念就是共享，如果资源不是共享的，那就没有必要进行同步。  

异步：asynchronized  
异步的概念是独立，互相之间没有影响；  

列子：  
1. a线程先持有object对象的lock锁，b线程如果这个时候调用对象中的同步方法则需等待，也就是同步；  
2. a线程先持有object对象的lock锁，b线程可以异步的调用对象中的非synchronized方法

<原来，以前的认知是错的。如果是一个对象，多个方法，都用syncrioized修饰，其中一个线程进入其中高一个方法后，别的线程是进入不了其他的方法的，因为synchrioized取得的是对象锁！！！而不是一段代码的锁！！！！只有等获取对象锁的线程释放锁后，别的线程才可以访问其他的synchrinozid方法>  


##脏读##
java多线程中的脏读：读取到了别人修改的值，并且是不希望读取到的值。
一般出现在业务本身具有原子性，但是没有进行同步操作，导致一部分数据修改了，一部分数据没有修改，
读出来的数据是错的。

oracle：undo概念，a客户端执行select操作，b客户端执行dml操作（insert，update等）；  
针对a客户端查询的那条数据，b进行了更新，因为b可能会更新失败，所以更新前这条数据数据会放在undo空间，假如更新失败，  
会把这条数据从undo空间取出，进行rollback回滚。  

而对于没有失败的情况，a先查询，b修改，a只会看到旧值，而不会看到b更改的值。    
snapshot too old:快照太老的异常    

##synchronized其他概念##  
1. 重入锁：这个对象的锁可以获取的。
2. sync修饰的方法出现了异常，会立即释放锁。  
意思是：一个业务整体，在执行过程中出现异常了，该如何做？  
 - 抛出一个RuntimeExcepption,这样即使在死循环中，也会中断；
 - continue，继续处理后续的（没有影响的）  
适用于多任务中，需要多任务必须同时成功或者失败，失败要回滚；  
或者失败记录日志

列子：存储过程书写中，10条记录遍历，其中第7条失败，不影响后续的，那就先写日志，继续；
对后续都有意影响，那就撤销之前的6条操作，全部回滚。记日志。  


##synchronized代码块##  
弊端：a线程的同步方法执行较长时间，那么b线程就必须等待较长时间才能执行。
这种情况下可以采用sync代码块去优化执行时间，减小锁的粒度。  

注意：不要使用string的常量加锁，容易出现死循环。
sync修饰类实例对象的锁  
类锁A.class  
声明一个对象，对象锁  


sync修饰的非静态方法，获取的是实列对象的锁；  
sync修饰静态方法，获取的是类锁；  
对象锁和类锁不是同一把锁，锁的范围也不一样；两把锁，一个线程可以同时获取。  


java的内置锁：每个java对象都可以用作一个实现同步的锁，这些锁成为内置锁。  
线程进入同步方法，同步代码块，会自动获取。在退出方法，释放锁。  
获得内置锁的唯一方法就是进入这个锁保护的 同步代码块，或者同步锁。  

对象锁：用于对象实例方法，或者一个对象实列上。  
类锁：类的静态方法，一个类的class对象。  

例子：  
两个线程，一个对象。  
类中两个方法，一个修饰代码块，一个修饰方法。  
执行的效果是：t1线程执行完了之后，t2线程才能进来。  
因为修饰代码块，修饰方法竞争的是同一把锁，即对象的内置锁。  

例子：  
两个线程，一个对象。  
类中两个方法，一个修饰static静态方法，一个修饰类对象。  
效果：t1执行完，t2才能进来。  
因为修饰静态方法，修饰类对象，竞争的是同一把锁。即类锁。  

例子：  
两个线程，一个对象。  
类中两个方法，一个修饰静态方法，一个修饰非静态方法。  
效果：交叉执行。  
因为修饰静态方法获取的是类锁，修饰非静态方法获取的是对象的内置锁，这两把锁不是同一把锁。
固可以同时执行。  

采用同步代码块或者同步方法，都会造成阻塞。  
但是有另外一种方法，采用同步代码块，声明一个锁。Object lock = new Oject();
在同步代码块中，对这个sync(lock)加锁，就可以保证不会阻塞其他线程，获取类的实列对象的锁。  
因为lock的内置锁和实列对象的锁，不是同一锁。  
同时也避免了同步代码块中的方法实现原子性。  


例子：  
两个线程，一个对象。
类中一个非静态方法，采用同步代码块，sync修饰（字符串常量）  
效果：t1执行完毕后，t2才能执行。  
因为两个线程获取的是同一把锁。  


例子：  
两个线程，一个对象。  
类中一个非静态方法，采用同步代码块，sync（new String（""））  
效果：交替执行。  
因为new出来的是不是同一个对象，获取不同的锁。


例子：  
两个线程，一个对象。  
类中一个非静态方法，采用同步代码块。  
sync(lock)，lock是在类的成员变量，且为string类型。 
并且在同步代码快中，对这个lock进行了修改值。  
效果：交替执行。  
因为string对象发生变化了，不再是同一把锁。所以这个时候sync就没作用了。



死锁   
两个线程互相持有对象想获取的锁，线程t1想获取锁a，但是它持有锁b；
线程t2想获取锁b，但是它持有锁a；  
这种情况就会造成死锁。  


##volatile关键字##  
概念：使变量在多个线程间可见。 
作用：线程到主存（共享内存）中去读取变量，而不是在自己的工作内存。  


早期做法：  
变量加锁，t1修改后放回主存，t2获取锁，去主存拿值。保证数据一致性。  
效率低，只有等t1释放锁之后，t2才可以获取锁，去修改变量的值。  

疑问：  
main中创建一个线程，调用Thread.sleep()，这个是主线程休眠，还是创建的线程休眠；  

volitale只是具备了可见性，并不是说具备了原子性。  
对数值计算，采用原子类，实现原子性。  
volatile：多个线程的可见，不能代替sync的同步功能。  

疑问：sync效率低是因为需要获取锁，获取不到就等待；
那volatile修饰的变量，如果一个线程对这个值修改，死循环了。那别的变量获取到的不就不是最新的了么？  

原子类：
只保证本身方法的原子性，不保证多次操作的原子性。  

##线程间通信##  
2.1.1
wait、notify 配置sync实现线程间通信。（object类的方法）  
1.wait notify配置sync使用。  
2.wait释放锁，notify不释放锁。  

2.1.2  
CountDownLatch中类型的两个方法，实现两个线程间实时等待唤醒。  
countDownLatch.countDaown(); 唤醒另一个线程
countDownLatch.await(); 暂停线程  

##ThreadLocal    
线程局部变量，是一种多线程间并发访问变量的解决方案。  
与sync等加锁的方式不同，ThreadLocal不提供锁，而是空间  
换时间的手段，为每个线程提供变量的独立副本，以保证线程安全。  

从性能上说，并发不高，加锁性能更好； 
并发高，ThreadLocal比较好，一定程度上减少锁竞争。

例子就是：
两个线程同时访问ThreadLocal类型的变量，结果是两个线程中访问的不是同一个。  
而是自己的一个拷贝。比如一个set，一个get，会发现get到的结果不一样。

##并发类容器  
concurrentMap容器：
concurrentHashMap  
concurrentSkipListMap --支持排序  
设计思想：减小锁的粒度。 


copyOnWrite容器：  
CopyOnWriteArrayList  
CopyOnWriteArraySet  
写时复制容器。写的时候，不操作当前容器，而是复制一个副本去写，写完之后将引用指向新的容器。  
好处是：并发读，不加锁，因为容器不会添加任何新元素。读写分离的思想。  
应用场景：读多，写少。  

问：多个写操作？
多个写操作采用reentrantLock，重入锁。进行阻塞操作。对于读操作，没有加锁操作。  

##Queue  
ConcurrentLinkedQueue  
高并发队列，无锁。性能好与BlockQueue,基于链接节点的无界限安全队列。先进新出。
方法：
add offer - 作用一样。无差别。  
poll,peek - 取出头节点，前者会删除元素，后者不会。

ArrayBlockingQueue  
基于数组，内部维护一个定长数组，阻塞，可以指定先进先出或先进后出，有界队列。

LinkedBlockingQueue  
基于链表，内部读写分离，实现生产者和消费者同时运行。

SynchronousQueue  
一种没有缓冲的队列，生产者产生的数据会被消费者获取并消费。  
队列容量是0。   
要点：不支持直接往队列中添加元素；可以采用两个线程，一个阻塞take，一个add，
take线程先启动，add线程后启动，这个是可以操作的。其中注意的是这个add不是往队列中  
添加元素了，而是直接把元素给了阻塞的take线程。   

PriorityBlockingQueue  
基于优先级的阻塞队列，添加对象必须实现Comparable接口。 
内部控制线程同步的锁采用公平锁，无界队列。  
往队列中添加元素不会进行排序，真正的获取优先级高的元素是在从队列中take元素的时候确定的。

Delayqueue  
带有延时时间，其中的元素只能在其指定的延迟时间后才能从队列中获取该元素。
必须实现Delay接口。
应用场景：对缓存超时数据进行移除，任务超时处理，空闲连接的关闭等。


##多线程的设计模式  
Future, Master-Worker,生产者消费者  

Future是异步模型；

生产者消费者
mq消息中间件