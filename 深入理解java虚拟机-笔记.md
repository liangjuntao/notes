注：学习新东西，尤其是工作中暂时用不到的，还是记录下吧。不然过一段时间，就全忘记了。

#第二章 java内存区域和内存溢出异常#

## java的内存分配 ##
- 程序计数器（线程私有，不共享）  
 1. 简单的说就是取指令总有先后的顺序，程序计数器的作用便是如此，根据程序计数器，便知道当前线程执行到哪条指令，下一条指令取哪条。如：多线程环境下，当前线程获得cpu调度，根据程序计数器便知道上次执行这个这个线程运行到哪条指令了，依次恢复。
 2. 分支，循环，跳转，异常处理，同样依赖程序计数器取下一条需要执行的字节码指令。  
- java虚拟机栈（线程私有，不共享）  
 1. 描述的是java方法执行的内存模型。每个方法在执行的时候都会创建一个栈帧用于存储局部变量，操作数栈，方法出口，动态链接等信息。  
 2. 局部变量表存放的是编译器可知的各种基本数据类型，对象引用。  
 3. 两种异常：①StackOverfollowError ②OutOfMemoryError。
 4. StackOverFlowError一般是递归调用时候，只有进栈操作，没有出栈，最终导致请求的栈深度大于虚拟机规定的深度。
 5. OutOfMeoryError，一般是不停的申请内存，创建对象实例，导致可申请的空间大于虚拟机允许分配的空间。
- 本地方法栈（线程私有，不共享）
 1. 本地方发展为虚拟机执行Native方法的内存空间。
 2. 虚拟机规范中，并没有强制规定，可以自由实现。
- java堆（线程共享）
 1. 线程共享
 2. 存放对象实例
 3. 垃圾回收的主要区域，有时也成为GC堆
- 方法区（线程共享）
 1. 存储被虚拟机加载的类信息（类版本，访问修饰符，字段，方法，接口），常量，静态变量，即时编译器编译后的代码。
 2. 别名是Non-Heap，非堆。
 3. 垃圾回收在方法区中主要是针对常量池的回收和对类型的卸载。
- 运行时常量池
 1. 运行时常量池是方法去的一部分。
 2. 存放编译器生成的各种字面量和符号引用，这部分内容是在类加载进入方法区的运行时常量池中存放。
 3. 除了class文件中的符号引用，直接引用也会存储在这块。
 4. 符号引用：一般是一个类中使用别的类方法，接口，字段，调用另一个类的方法，会有这个符号引用。
 5. String intern()方法，运行时放入方法区。
- 直接内存
 1. 不是java虚拟机规范中定义的内存区域。
 2. 收操作系统级别限制，会出现内存溢出的报错。
 3. NIO中，使用Native函数库直接分配堆外内存。其中，DirectByteBuffer直接操作的内存便是基于这块儿内存。

## 虚拟机对象探秘 ##
- 对象的创建</br>*p45页，代码2-1*
 1. 遇到new指令，现在常量池中定位是否有这个类的符号引用。并且检查这个类是否加载，解析，初始化。如果没有，先执行类加载过程。
 2. 类加载检查通过后，为新生对象分配内存。有两种分配方式，①指针碰撞，②空闲列表。**分配不是线程安全的。**两种解决办法：① CAS配上失败重试保证原子操作 ②分配动作按照线程划分在两个空间中，-XX:+/-UseTLAB参数决定。
 3. 内存空间初始化0值。不包括对象头。
 4. 对对象头进行必要的设置。如：对象是哪个类的实例，如何找类的元数据信息，对象的哈希码，对象的GC分代年龄等。这些信息存储在对象头中。
 5. 接着执行init()方法，由字节码中是否跟随invokespecial执行决定，按照程序员的意愿初始化，这样一个可用的对象初始化完毕。
 
- 对象的内存布局
 1. 对象头  
 ① 存储对象自身运行时的数据。哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。  
 ② 类型指针。对象执向它的类元数据指针，我是哪个类的实例。  
 2. 实例数据  
  ① 对象真正的存储信息，代码中定义的各种类型字段内容。  
  ② 不仅存储自己的，也会存储父类的。按照字节大小和父子关系，有顺序。参数可调，CompactFields。  
 3. 对齐填充  
 没特殊含义，占位符。

- 对象的访问定位
 1. 创建对象是为了使用数据 ，程序通过Reference数据来操作堆上的具体对象。两种访问方式：① 使用句柄 ②直接指针
 2. 使用句柄。Reference->句柄池，句柄池->对象实例数据和对象类型数据。三次指针定位。
 3. 直接指针。Reference->对象类型数据（包含到对象类型的指针）,对象类型指针->对象类型数据。两次指针定位，速度更快。

- OutOfMemoryError
 1. java堆溢出。不断创建对象
 2. 虚拟机栈和本地方法栈大小。在32位虚拟机中，建立过多线程会导致内存溢出。**通过"减少内存"的手段来解决内存溢出。**
 3. 方法区和运行时常量池。动态生成class加载的情况下容易出现。
 4. 本机直接内存溢出。NIO时候，容易出现。

- 堆参数介绍  
 1. `-Xms` 最小堆的大小， 也就是当你的虚拟机启动后， 就会分配这么大的堆内存给你   
 2. `-Xmx` 是最大堆的大小  
当最小堆占满后，会尝试进行GC，如果GC之后还不能得到足够的内存(GC未必会收集到所有当前可用内存)，分配新的对象，那么就会扩展堆，如果-Xmx设置的太小，扩展堆就会失败，导致OutOfMemoryError错误提示。
 3. `-Xss`设置stack space，这个值比较小。128k就够用了。
 4. `-XX:PermSize`和`-XX：MaxPermSize`限制方法区大小，简介限制其中常量池的容量。提示：PermGen space。

# 第三章 垃圾收集器与内存分配策略 #
#概述#

**基本算法**  

- 引用计数算法  
**介绍**：给对象设置一个引用计数器，当有一个地方引用的时候，计数器加1；引用实效时，计数器减1；任何时候，计数器为0的对象就不可以再被使用。  
**缺点**：难以解决两个对象之间互相引用，但是这两个对象都已经不再使用的问题。  
**注**：虚拟机并不是使用通过引用计数算法来判定对象时候还存活。  

- 可达性分析算法  
**介绍**：通过“GC Roots”的对象作为起点，从这些节点向下搜索，搜索走过的路径成为引用链，当一个对象到“GC Roots”节点没有任何引用链相连的话，则证明此对象不可用的。  
**GC Roots**： ①虚拟机栈（栈帧中的本地变量）中引用的对象；②方法区中类静态属性引用的对象；③方法区中常量引用的对象；④本地方法栈JNI（一般说的Native方法）引用的对象。  
 
**引用**  

- jdk1.2之前  
**介绍**：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就说着代表着一种引用。  
  **缺点**：过滤纯粹。我们希望描述的是，当内存空间足够的时候，保留在内存中；如果发生过GC后，内存空间还是比较紧张，那就清除这些对象。  

- jdk1.2之后  
 1. 强引用。类似于 A a = new A();有用且必须；发出OutOfMemory,垃圾回收也不会清理这个对象；
 2. 软引用。有用非必需，生存到第二次垃圾回收；在发出OutOfMemory，将会把这些对象放入二次回收对象中。第一次之后，还存在；第二次回收，如果这次回收内存还不足，那就发出OutOfMemory;
 3. 弱引用。无用非必须；只能生存到下一次垃圾回收之前；无论内存够不够，都会被回收。
 4. 虚引用。一个对象是否有虚引用，会生命周期没有任何影响；一般用作这个对象被回收时，能发出一个信息说我要被回收之用。有点监测被回收的意思。  

**宣告一个对象死亡，两次标记过程**  
1. 第一次标记：可达性分析后发现没有与GC Roots相连接的引用链，那么会第一次进行标记，并进行以此筛选。    
 - 筛选条件是：有没有必要执行finalize9()方法。  
 - 两种情况被视为没有必要执行：此对象没有重写finalize()方法，或者finalize()已经被虚拟机调用过。  
2. 如果被判定为有必要执行finalize()方法，加入F-Queue队列之中。进行第二次标记。  
 - 在finalize()方法中，只有一个办法拯救这个对象不被回收。那就是与其他对象发生关联。  
注：finalize()只会被执行一次。也就说一个对象的finalize()方法只会被调用一次，如果调用之后没有被回收，下一次finalize()方法不会被执行，直接回收。  

**方法区的回收**  
主要回收两部分内容：废弃常量和无用的类。  
- 废弃常量：如果一个常量没有被引用，那就清楚。  
- 无用的类：判定条件比较复杂。  
 1. 该类所有的实列都已经被回收；  
 2. 加载该类的ClassLoader已经被回收；  
 3. 该类对应的java.lang.Class对象没有任何地方引用，无法通过反射访问该类。

**垃圾收集算法**  

- 标记-清除   
 1. 标记：采用可达性分析算法
 2. 清除：标记之后统一清除    
 3. **缺点**：①效率低 ② 产生不连续的空间碎片，导致分配大对象的时候，内存不足，再次出发gc；  

- 复制  
 1. 将内存分为一个Eden，和两个Survivor区。每次只使用Eden和一个Survivor区。默认比例是8：1：1；
 2. 垃圾回收时，讲eden和survivor区中存活的对象，移入另一个survivor中；避免产生大量空间碎片。
 3. 当survivor空间不足时候，会进入老年代。(常规情况是在两个survivor中来回复制，达到一定年龄才会进入老年代)  
 4. **缺点**：如果存活率很高，会有很多次复制操作，效率会很低。
 
- 标记-整理  
 1. 标记：和标记清除算法一样
 2. 整理：不是直接对可回收对象进行清除，而是让所有存活对象都往一边移动，达到有连续空间的目的。  

- 分代收集算法
 1. 当前商业虚拟机都是采用分代。
 2. 分为新生代和老年代。新生代存活率低，采用复制算法；老年代存活率搞，采用标记-整理或者标记-清除。


**收集器相关**  
*太多了，p72，需要的时候查阅吧*

**整个大概的过程**  
 - 新对象会被分配在Eden(年轻代)中；在一次minorGc之后，存活对象进入一个Sur中，再经过一次Gc，进入到另一个Sur中；之后一直在两个Sur中循环，直到达到一定的年龄，会进入老年代中； 
注：永久代在方法区中，不是堆中的对象可进去的！  
 - 大对象（新）会直接进入老年代；


# 第四章 虚拟机性能监控与故障处理工具 #

- jps  
列出正在运行的虚拟机进程，并且显示虚拟机执行主类名称，本地虚拟机唯一标示lvmid

- jstat  
列出虚拟机各种运行状态信息的命令行工具  
如：类装载，垃圾回收，运行期编译状况等

- jinfo  
实时查询和调整虚拟机各项参数

注：暂时先不看调优这块儿了，直接跳到第六章


