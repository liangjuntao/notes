注：学习新东西，尤其是工作中暂时用不到的，还是记录下吧。不然过一段时间，就全忘记了。

#第二章 java内存区域和内存溢出异常#

## java的内存分配 ##
- 程序计数器（线程私有，不共享）  
1. 简单的说就是取指令总有先后的顺序，程序计数器的作用便是如此，根据程序计数器，便知道当前线程执行到哪条指令，下一条指令取哪条。如：多线程环境下，当前线程获得cpu调度，根据程序计数器便知道上次执行这个这个线程运行到哪条指令了，依次恢复。
2. 分支，循环，跳转，异常处理，同样依赖程序计数器取下一条需要执行的字节码指令。  
- java虚拟机栈  
 1. 描述的是java方法执行的内存模型。每个方法在执行的时候都会创建一个栈帧用于存储局部变量，操作数栈，方法出口，动态链接等信息。  
 2. 局部变量表存放的是编译器可知的各种基本数据类型，对象引用。  
 3. 两种异常：①StackOverfollowError ②OutOfMemoryError。
 4. StackOverFlowError一般是递归调用时候，只有进栈操作，没有出栈，最终导致请求的栈深度大于虚拟机规定的深度。
 5. OutOfMeoryError，一般是不停的申请内存，创建对象实例，导致可申请的空间大于虚拟机允许分配的空间。
- 本地方法栈
 1. 本地方发展为虚拟机执行Native方法的内存空间。
 2. 虚拟机规范中，并没有强制规定，可以自由实现。
- java堆（线程共享）
 1. 线程共享
 2. 存放对象实例
 3. 垃圾回收的主要区域，有时也成为GC堆
- 方法区（线程共享）
 1. 存储被虚拟机加载的类信息（类版本，访问修饰符，字段，方法，接口），常量，静态变量，即时编译器编译后的代码。
 2. 别名是Non-Heap，非堆。
 3. 垃圾回收在方法区中主要是针对常量池的回收和对类型的卸载。
- 运行时常量池
 1. 运行时常量池是方法去的一部分。
 2. 存放编译器生成的各种字面量和符号引用，这部分内容是在类加载进入方法区的运行时常量池中存放。
 3. 除了class文件中的符号引用，直接引用也会存储在这块。
 4. 符号引用：一般是一个类中使用别的类方法，接口，字段，调用另一个类的方法，会有这个符号引用。
 5. String intern()方法，运行时放入方法区。
- 直接内存
 1. 不是java虚拟机规范中定义的内存区域。
 2. 收操作系统级别限制，会出现内存溢出的报错。
 3. NIO中，使用Native函数库直接分配堆外内存。其中，DirectByteBuffer直接操作的内存便是基于这块儿内存。

## 虚拟机对象探秘 ##
- 对象的创建</br>*p45页，代码2-1*
 1. 遇到new指令，现在常量池中定位是否有这个类的符号引用。并且检查这个类是否加载，解析，初始化。如果没有，先执行类加载过程。
 2. 类加载检查通过后，为新生对象分配内存。有两种分配方式，①指针碰撞，②空闲列表。**分配不是线程安全的。**两种解决办法：① CAS配上失败重试保证原子操作 ②分配动作按照线程划分在两个空间中，-XX:+/-UseTLAB参数决定。
 3. 内存空间初始化0值。不包括对象头。
 4. 对对象头进行必要的设置。如：对象是哪个类的实例，如何找类的元数据信息，对象的哈希码，对象的GC分代年龄等。这些信息存储在对象头中。
 5. 接着执行init()方法，由字节码中是否跟随invokespecial执行决定，按照程序员的意愿初始化，这样一个可用的对象初始化完毕。
 
- 对象的内存布局
 1. 对象头
 - 存储对象自身运行时的数据。哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。
 - 类型指针。对象执向它的类元数据指针，我是哪个类的实例。
 2. 实例数据
 - 对象真正的存储信息，代码中定义的各种类型字段内容。
 - 不仅存储自己的，也会存储父类的。按照字节大小和父子关系，有顺序。参数可调，CompactFields。
 3. 对齐填充
 - 没特殊含义，占位符。

- 对象的访问定位
 1. 创建对象是为了使用数据 ，程序通过Reference数据来操作堆上的具体对象。两种访问方式：① 使用句柄 ②直接指针
 2. 使用句柄。Reference->句柄池，句柄池->对象实例数据和对象类型数据。三次指针定位。
 3. 直接指针。Reference->对象类型数据（包含到对象类型的指针）,对象类型指针->对象类型数据。两次指针定位，速度更快。

- OutOfMemoryError
 1. java堆溢出。不断创建对象
 2. 虚拟机栈和本地方法栈大小。在32位虚拟机中，建立过多线程会导致内存溢出。**通过"减少内存"的手段来解决内存溢出。**
 3. 方法区和运行时常量池。动态生成class加载的情况下容易出现。
 4. 本机直接内存溢出。NIO时候，容易出现。

- 堆参数介绍  
 1. `-Xms` 最小堆的大小， 也就是当你的虚拟机启动后， 就会分配这么大的堆内存给你   
 2. `-Xmx` 是最大堆的大小  
当最小堆占满后，会尝试进行GC，如果GC之后还不能得到足够的内存(GC未必会收集到所有当前可用内存)，分配新的对象，那么就会扩展堆，如果-Xmx设置的太小，扩展堆就会失败，导致OutOfMemoryError错误提示。
 3. `-Xss`设置stack space，这个值比较小。128k就够用了。
 4. `-XX:PermSize`和`-XX：MaxPermSize`限制方法区大小，简介限制其中常量池的容量。提示：PermGen space。
