注：学习新东西，尤其是工作中暂时用不到的，还是记录下吧。不然过一段时间，就全忘记了。

#第二章 java内存区域和内存溢出异常#

## java的内存分配 ##
- 程序计数器（线程私有，不共享）  
 1. 简单的说就是取指令总有先后的顺序，程序计数器的作用便是如此，根据程序计数器，便知道当前线程执行到哪条指令，下一条指令取哪条。如：多线程环境下，当前线程获得cpu调度，根据程序计数器便知道上次执行这个这个线程运行到哪条指令了，依次恢复。
 2. 分支，循环，跳转，异常处理，同样依赖程序计数器取下一条需要执行的字节码指令。  
- java虚拟机栈（线程私有，不共享）  
 1. 描述的是java方法执行的内存模型。每个方法在执行的时候都会创建一个栈帧用于存储局部变量，操作数栈，方法出口，动态链接等信息。  
 2. 局部变量表存放的是编译器可知的各种基本数据类型，对象引用。  
 3. 两种异常：①StackOverfollowError ②OutOfMemoryError。
 4. StackOverFlowError一般是递归调用时候，只有进栈操作，没有出栈，最终导致请求的栈深度大于虚拟机规定的深度。
 5. OutOfMeoryError，一般是不停的申请内存，创建对象实例，导致可申请的空间大于虚拟机允许分配的空间。
- 本地方法栈（线程私有，不共享）
 1. 本地方发展为虚拟机执行Native方法的内存空间。
 2. 虚拟机规范中，并没有强制规定，可以自由实现。
- java堆（线程共享）
 1. 线程共享
 2. 存放对象实例
 3. 垃圾回收的主要区域，有时也成为GC堆
- 方法区（线程共享）
 1. 存储被虚拟机加载的类信息（类版本，访问修饰符，字段，方法，接口），常量，静态变量，即时编译器编译后的代码。
 2. 别名是Non-Heap，非堆。
 3. 垃圾回收在方法区中主要是针对常量池的回收和对类型的卸载。
- 运行时常量池
 1. 运行时常量池是方法去的一部分。
 2. 存放编译器生成的各种字面量和符号引用，这部分内容是在类加载进入方法区的运行时常量池中存放。
 3. 除了class文件中的符号引用，直接引用也会存储在这块。
 4. 符号引用：一般是一个类中使用别的类方法，接口，字段，调用另一个类的方法，会有这个符号引用。
 5. String intern()方法，运行时放入方法区。
- 直接内存
 1. 不是java虚拟机规范中定义的内存区域。
 2. 收操作系统级别限制，会出现内存溢出的报错。
 3. NIO中，使用Native函数库直接分配堆外内存。其中，DirectByteBuffer直接操作的内存便是基于这块儿内存。

## 虚拟机对象探秘 ##
- 对象的创建</br>*p45页，代码2-1*
 1. 遇到new指令，现在常量池中定位是否有这个类的符号引用。并且检查这个类是否加载，解析，初始化。如果没有，先执行类加载过程。
 2. 类加载检查通过后，为新生对象分配内存。有两种分配方式，①指针碰撞，②空闲列表。**分配不是线程安全的。**两种解决办法：① CAS配上失败重试保证原子操作 ②分配动作按照线程划分在两个空间中，-XX:+/-UseTLAB参数决定。
 3. 内存空间初始化0值。不包括对象头。
 4. 对对象头进行必要的设置。如：对象是哪个类的实例，如何找类的元数据信息，对象的哈希码，对象的GC分代年龄等。这些信息存储在对象头中。
 5. 接着执行init()方法，由字节码中是否跟随invokespecial执行决定，按照程序员的意愿初始化，这样一个可用的对象初始化完毕。
 
- 对象的内存布局
 1. 对象头  
 ① 存储对象自身运行时的数据。哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。  
 ② 类型指针。对象执向它的类元数据指针，我是哪个类的实例。  
 2. 实例数据  
  ① 对象真正的存储信息，代码中定义的各种类型字段内容。  
  ② 不仅存储自己的，也会存储父类的。按照字节大小和父子关系，有顺序。参数可调，CompactFields。  
 3. 对齐填充  
 没特殊含义，占位符。

- 对象的访问定位
 1. 创建对象是为了使用数据 ，程序通过Reference数据来操作堆上的具体对象。两种访问方式：① 使用句柄 ②直接指针
 2. 使用句柄。Reference->句柄池，句柄池->对象实例数据和对象类型数据。三次指针定位。
 3. 直接指针。Reference->对象类型数据（包含到对象类型的指针）,对象类型指针->对象类型数据。两次指针定位，速度更快。

- OutOfMemoryError
 1. java堆溢出。不断创建对象
 2. 虚拟机栈和本地方法栈大小。在32位虚拟机中，建立过多线程会导致内存溢出。**通过"减少内存"的手段来解决内存溢出。**
 3. 方法区和运行时常量池。动态生成class加载的情况下容易出现。
 4. 本机直接内存溢出。NIO时候，容易出现。

- 堆参数介绍  
 1. `-Xms` 最小堆的大小， 也就是当你的虚拟机启动后， 就会分配这么大的堆内存给你   
 2. `-Xmx` 是最大堆的大小  
当最小堆占满后，会尝试进行GC，如果GC之后还不能得到足够的内存(GC未必会收集到所有当前可用内存)，分配新的对象，那么就会扩展堆，如果-Xmx设置的太小，扩展堆就会失败，导致OutOfMemoryError错误提示。
 3. `-Xss`设置stack space，这个值比较小。128k就够用了。
 4. `-XX:PermSize`和`-XX：MaxPermSize`限制方法区大小，简介限制其中常量池的容量。提示：PermGen space。

# 第三章 垃圾收集器与内存分配策略 #
#概述#

**基本算法**  

- 引用计数算法  
**介绍**：给对象设置一个引用计数器，当有一个地方引用的时候，计数器加1；引用实效时，计数器减1；任何时候，计数器为0的对象就不可以再被使用。  
**缺点**：难以解决两个对象之间互相引用，但是这两个对象都已经不再使用的问题。  
**注**：虚拟机并不是使用通过引用计数算法来判定对象时候还存活。  

- 可达性分析算法  
**介绍**：通过“GC Roots”的对象作为起点，从这些节点向下搜索，搜索走过的路径成为引用链，当一个对象到“GC Roots”节点没有任何引用链相连的话，则证明此对象不可用的。  
**GC Roots**： ①虚拟机栈（栈帧中的本地变量）中引用的对象；②方法区中类静态属性引用的对象；③方法区中常量引用的对象；④本地方法栈JNI（一般说的Native方法）引用的对象。  
 
**引用**  

- jdk1.2之前  
**介绍**：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就说着代表着一种引用。  
  **缺点**：过滤纯粹。我们希望描述的是，当内存空间足够的时候，保留在内存中；如果发生过GC后，内存空间还是比较紧张，那就清除这些对象。  

- jdk1.2之后  
 1. 强引用。类似于 A a = new A();有用且必须；发出OutOfMemory,垃圾回收也不会清理这个对象；
 2. 软引用。有用非必需，生存到第二次垃圾回收；在发出OutOfMemory，将会把这些对象放入二次回收对象中。第一次之后，还存在；第二次回收，如果这次回收内存还不足，那就发出OutOfMemory;
 3. 弱引用。无用非必须；只能生存到下一次垃圾回收之前；无论内存够不够，都会被回收。
 4. 虚引用。一个对象是否有虚引用，会生命周期没有任何影响；一般用作这个对象被回收时，能发出一个信息说我要被回收之用。有点监测被回收的意思。  

**宣告一个对象死亡，两次标记过程**  
1. 第一次标记：可达性分析后发现没有与GC Roots相连接的引用链，那么会第一次进行标记，并进行以此筛选。    
 - 筛选条件是：有没有必要执行finalize9()方法。  
 - 两种情况被视为没有必要执行：此对象没有重写finalize()方法，或者finalize()已经被虚拟机调用过。  
2. 如果被判定为有必要执行finalize()方法，加入F-Queue队列之中。进行第二次标记。  
 - 在finalize()方法中，只有一个办法拯救这个对象不被回收。那就是与其他对象发生关联。  
注：finalize()只会被执行一次。也就说一个对象的finalize()方法只会被调用一次，如果调用之后没有被回收，下一次finalize()方法不会被执行，直接回收。  

**方法区的回收**  
主要回收两部分内容：废弃常量和无用的类。  
- 废弃常量：如果一个常量没有被引用，那就清楚。  
- 无用的类：判定条件比较复杂。  
 1. 该类所有的实列都已经被回收；  
 2. 加载该类的ClassLoader已经被回收；  
 3. 该类对应的java.lang.Class对象没有任何地方引用，无法通过反射访问该类。

**垃圾收集算法**  

- 标记-清除   
 1. 标记：采用可达性分析算法
 2. 清除：标记之后统一清除    
 3. **缺点**：①效率低 ② 产生不连续的空间碎片，导致分配大对象的时候，内存不足，再次出发gc；  

- 复制  
 1. 将内存分为一个Eden，和两个Survivor区。每次只使用Eden和一个Survivor区。默认比例是8：1：1；
 2. 垃圾回收时，讲eden和survivor区中存活的对象，移入另一个survivor中；避免产生大量空间碎片。
 3. 当survivor空间不足时候，会进入老年代。(常规情况是在两个survivor中来回复制，达到一定年龄才会进入老年代)  
 4. **缺点**：如果存活率很高，会有很多次复制操作，效率会很低。
 
- 标记-整理  
 1. 标记：和标记清除算法一样
 2. 整理：不是直接对可回收对象进行清除，而是让所有存活对象都往一边移动，达到有连续空间的目的。  

- 分代收集算法
 1. 当前商业虚拟机都是采用分代。
 2. 分为新生代和老年代。新生代存活率低，采用复制算法；老年代存活率搞，采用标记-整理或者标记-清除。


**收集器相关**  
*太多了，p72，需要的时候查阅吧*

**整个大概的过程**  
 - 新对象会被分配在Eden(年轻代)中；在一次minorGc之后，存活对象进入一个Sur中，再经过一次Gc，进入到另一个Sur中；之后一直在两个Sur中循环，直到达到一定的年龄，会进入老年代中； 
注：永久代在方法区中，不是堆中的对象可进去的！  
 - 大对象（新）会直接进入老年代；


# 第四章 虚拟机性能监控与故障处理工具 #

- jps  
列出正在运行的虚拟机进程，并且显示虚拟机执行主类名称，本地虚拟机唯一标示lvmid

- jstat  
列出虚拟机各种运行状态信息的命令行工具  
如：类装载，垃圾回收，运行期编译状况等

- jinfo  
实时查询和调整虚拟机各项参数

注：暂时先不看调优这块儿了，直接跳到第六章

# 类文件结构 #
## 实现语言无关性 ##
1. 首先明白，.class文件包含了java虚拟机指令集和符号表以及其他若干辅助信息。  
2. 其次，java虚拟机不和任何语言（包括java）绑定，它只是与"Class文件"这种特定的二进制文件格式关联。  
3. 最后，如果一门别的语言按照java虚拟机规范，编译生成.class文件符合规范，那也是可以运行在java虚拟机上的。  

## Class文件结构 ##
**class文件格式**：  
1. 任何一个class文件都对应一个类或接口的定义信息；反过来说是不对的，因为类可以通过类加载器生成。  
2. class文件格式采用类似c的伪结构来存储数据。只有两种数据类型：无符号数和表。  
 - 无符号数：u1,u2,u4,u8,代表一个字节，两个字节，4个字节，8个字节。用来描述数字，索引引用，数值量，字符串。    
 - 表：多个无符号数，其他表作为数据项。以_info结尾。用来描述有层次关系的符合结构的数据。  
 - 描述同一类型但数量不定的数据采用：前置的容量计数器+连续数据项

3. .class文件是有严格限制的。顺序，数量，长度等都有固定的含义。不能随便更改。

**魔数与class版本：前8个字节**      
确定这个文件是否为一个能被虚拟机接受的class文件；class次版本号，class主版本号；和jdk版本有强相关，低版本的不一定支持高版本。  

**常量池：2个字节 + n：**  
clas文件中的资源仓库。
两个字节：常量的个数。索引从1开始，1~xx；0代表没有常量。  

常量池存放两类常量：字面量，符号引用。  

- 字面量。
 1. 文本字符串，final类型的常量
 
- 符号引用：虚拟机在编译的时候，不会保存方法，字段的最终内存布局，也就是无法被虚拟机使用。只有到类加载的时候，根据常量池的符号引用去解析，翻译为具体的内存地址。  
 1. 类和接口的全限定名
 2. 字段的名称和描述符
 3. 方法的名称和描述符

常量池中的每个常量都是一张表；总共有14中类型。第一位都是tag，用来表示这个常量是什么类型的常量。  


**访问标志**  
表示类或接口的访问信息；public,static,final等  

**类索引，父类索引与接口索引集合**  
用这三项数据来确定这个类的继承关系。  
- 类索引：确定这个类的全限定名。  
- 父类索引：确定父类的全限定名。  
- 接口索引集合：描述这个类实现了哪些接口。  

**字段表集合**  
用来描述接口或者类的声明的变量。但是不包括方法内的局部变量。  

1. 可以包括的信息有：    
 - 作用域：public,private,protected  
 - 实例变量or类变量：static  
  - 可见性：final  
 - 并发可见性：volatile修饰符，是否从主内存而不是缓存读取  
 - 是否被序列化：transient  
 - 字段数据类型：基本类型，对象，数组  
 - 是否枚举类型：enum  

2. 全限定名：/org/fenixsoft/clazz/TestClass  
3. 简单名称：没有类型和参数修饰的方法或字段的名称。如：get,setAge  
4. 描述符：字段的数据类型，方法的参数列表（数量，类型，顺序），返回值  
如：[[Ljava/lang/String; 这个是定义了一个"java.lang.String[][]"数组的描述符。*p177*


**方法表集合**    
1. 方法访问标志 
public,private,protected,static,final,synchronized,native,abstract,strictfp  
2. 具体的代码，放入Code属性中  
3. 典型的类构造器<client>,实列构造器<init>方法  

**属性表集合**  
class文件，字段表，方法表都可以携带自己的属性表集合。  
*p181*



- ConstantValue  
对于非static变量的赋值是在实例构造器中`<init>`进行的；  
对于static类型：final,static修饰的字符串和基本类型，用ConstantValue属性；没有final，非基本类型或字符串，`<init>`。


**关于this：**  
在任何实例方法中，都可以通过this关键字访问到此方法所属的对象。实现：通过javac编译器编译的时候把this关键字的访问转变为对一个普通方法参数的访问，然后再虚拟机调用实列方法的时候自动传入此参数。


## 指令 ##
**同步指令**  
jvm支持方法级的同步和方法内部一段指令序列的同步，这两种同步都采用管程来支持(Monitor)。  

方法级的同步是隐式的；当方法调用的时候，调用指令会检查ACC_SYSCHRONIZED访问标志是否被设置，如果设置了，执行线程要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。
*以前看操作系统的时候，管程和java sync关系总是不明白。现在知道了操作系统级别的类似是是jvm中的实现。sync关键字只是对底层实现的一种封装。*  

## 操作系统级别和jvm级别的存储实现 ##
1. 将输入的java虚拟机代码在加载或者执行的时候翻译成另一种虚拟机指令集。  
2. 将输入的java虚拟机代码在加载或执行时翻译成宿主机cpu的本地指令集。（jit：即时编译器，热点代码-->物理机指令集）  






# 第七章 虚拟机类加载机制 #
特性：运行期动态加载，动态链接

## 类加载的生命周期   ##
加载，验证，准备，解析，初始化，使用，卸载  


## 5种立即初始化 ##


## 类加载的过程  ##
### 1. 加载 ###

**加载阶段，完成三件事**  

- 通过类的全限定名获取定义此类的二进制字节流
- 将这个字节流代表的静态存储结构转化为方法区运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区对这个类的各种数据的访问入口  

**数组类型和非数组类型的区别**  
  
- 非数组类的加载阶段，可使用系统提供的类加载器加载，也可以自定义类加载器加载。（继承ClassLoader，重写findClass()方法）。  
- 数组类型：不通过类加载器创建，直接由java虚拟机直接创建。 
- 规则：
 1. 数组的组件类型如果是对象类型，那就采用此对象的类加载器去加载这个组件。
 2. 如果不是引用类型，即非对象类型；如：int[] ，会将这个数组标记为与引导类加载器关联。
 3. 可见性和组件类型的可见性一致。数组默认public。

### 2. 验证 ###
**目的**   
确保class字节流包含的信息符合虚拟机要求，不会对虚拟机自身的安全。    

**步骤**

1. 文件格式验证
 - 魔数，主次版本号，非法常量类型，不符合utf-8，class字节文件完整性等。主要是格式上的。
2. 元数据验证
 - 语义级别。要符合java语言规范。
 - 是否有父类
 - 是否继承了不被允许的类，final修饰的类
 - 是否实现了接口中的方法
 - 类中的字段，方法是否和父类产生锚段。如：不符合格式的重载，覆盖父类final字段
3. 字节码验证
 - 语义合法，符合逻辑
 - 操作数栈的数据类型和指令序列配合工作。如：操作数栈放了一个int类型的值，使用时却按long类型去加载到本地变量表
 - 跳转指令不会跳到别的字节码指令。如：跳出for循环定义的标识地方
 - 类型转换是有效的。父类引用子类，ok；子类引用父类，no
4. 符号引用验证
 - 虚拟机将符号引用转化为直接引用时使用
 - 符号引用中通过字符串描述符的全限定名是否可以找到对应的类
 - 指定类中是否存在符合方法的字段描述符；
 - 访问控制是否允许，private,protected,default,public

    注：可通过参数取消验证 -Verify:none



### 3. 准备 ###
为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都在方法区中进行分配。  

仅包括类变量static修饰的，不包括实列变量；  
实例变量在对象实列的时候再堆中分配和初始化。  

注：static final 修饰的，在准备阶段采用ConstantValue直接赋值。  


### 4. 解析 ###
将符号引用转化为直接引用的阶段。  

- 符号引用：符号引用是字面量，只要无歧义能找到目标就行；符合引用和虚拟机实现的内存布局没关系，引用的目标不一定已经加载到内存中了。
- 直接引用：直接指向目标的指针；直接引用和内存布局有关系，如果有了直接引用，那引用的目标必定在内存中。

### 5. 初始化 ###
在准备阶段，已经有一次初始化操作了。接下来是第二次初始化操作。  

类构造器<client>方法的过程：  
包含所有类变量，static{}中的语句块产生；  

类中：client方法会保证先调用父类的client方法；  
接口中：接口中没有static块儿，但有变量的初始化。接口中client初始化，不会先执行父类的client方法；除非使用了父接口中定义的变量； 

自动实现加锁，保证多线程初始化线程安全。


## 类加载器 ##
### 类和类加载器 ###
任意一个类，唯一性有类和类加载器保证；  
这里的相等说的是.equals isstanceOf()相等；  

### 双亲委派模型 ###
**三种类加载器**  

- 启动类加载器 Bootstrap ClassLoader , java_home/lib目录下的类；
- 扩展类加载器 Extension ClassLoader ,java_home/lib/ext目录下的类；
- 应用程序类加载器 Application ClassLoader ,一般称为系统类加载器；负责加载用户classPath上指定的类库；

**双亲委派模型的工作过程**  

1. 类加载器收到类加载请求，首先自己不加载，而是交给父类加载器；因此所有的加载请求都传送到了启动类加载器中；  
2. 当父类加载器反馈自己无法加载请求（搜索范围中没有），子加载器会去自己加载。  

**双亲委派好处**

- java类和它的类加载器建立一种层级关系。如：java.lang.Object存放在rt.jar中，无论哪个加载器去加载，最后都会有启动类加载器去加载；
- 若不是这种模型；用户自己写一个java.lang.Object,放入classPath中，那系统会有多个Object类，混乱！  

**破坏双亲委派模型**  
首先要明白，双亲委派不是强制要求的，只是大家遵守的一种规则；   
可以继承ClassLoader，重写loadClass()方法，就会破坏这种规则；  
不破坏的做法是，重写findClass()方法；  

**OGGI实现模块化部署**  
自定义类的加载器。每一个程序模块Bundle都有一个自己的类加载器，如果要换掉一个模块的时候，连同类加载器一起换掉实现代码的热替换；
