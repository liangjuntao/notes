###经典io/nio/aio中的问题：    
tcp读包写包问题，数据接收的大小，实际通信读取与应答处理逻辑。  

  
###netty通信步骤：  
 1. 两个nio线程组，一个接受客户端连接，一个进行网络读写。  
 2. ServerBootstrap对象，配置netty参数。  
 3. 实际处理数据的类ChannelInitalizer。  
 4. 绑定端口，执行同步阻塞方法等待服务端启动即可。  
  
###长短连接：  
 1. 长连接：不调用addListener方法，一直保持和服务器端的链接。    
 2. 短连接：一次请求，响应的链接。有点类似http请求，短连接。  

  
###实际工作中netty如何应用：  
 1. web应用中写netty服务的代码，随tomcat一起启动；在tomcat启动的时候把netty服务也启动；  
这样netty和tomcat生命周期强耦合，重量级。通信量不大的时候，可以。    
 2. 把netty服务单独打jar包，单独部署。和web应用独立开。  
使用方法：把netty服务依赖的web应用同时打包，如do入库操作。（推荐使用）  
  

###tcp拆包、粘包问题：  
 1. 设置特殊分隔符，比如"#—"， 看到一个"#_"，就当做一个包。（常用）  
 2. 消息定长，固定长度。不够空格补位。
 3. 自定义协议，安全，麻烦。不常用。  

###netty编解码技术  
常用编解码框架：  
jboss-->marshalling  
google-->protubuf  
基于protubuf的更优秀的kyro    
messagePack    

java序列化无法跨语言，序列化后码流太大，序列化性能太低。  

**Jboss Marshalling**  
注意：两个通信的服务端实体类包名+类名，必须一致。序列化id无所谓。  
  

###数据通信  
三种情况：  

- 使用长连接，不断开。客户端数量少的时候，推荐使用。
- 一次性批量提交数据，采用短连接。将需要提交的数据缓存下来，达到缓冲临界点时，打开连接一次性提交。实时性要求不高的情况下，推荐使用。
- 特殊的长连接，设置超时时间，如果超时则断开连接。客户端再次发请求的时候，再次建立长连接。类似线程池的超时断开连接。



###心跳检测  
维护多台服务器集群的时候，master-slave之间做心跳监控。  


 